<!DOCTYPE html>
<html class="dark" lang="en">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>AI Handwriting Synthesis Studio</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,container-queries"></script>
    <script src="/static/js/imagetracer.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&amp;family=JetBrains+Mono:wght@400;500&amp;display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&amp;display=swap" rel="stylesheet"/>
    <script>
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "lab-bg": "#0D1117",
                        "lab-border": "#30363D",
                        "lab-blue": "#00A3FF",
                        "lab-green": "#A6FF00",
                        "lab-card": "#161B22",
                        "lab-muted": "#8B949E",
                        "background-light": "#FFFFFF",
                        "background-dark": "#0D1117",
                        "paper-light": "#E6E6E6", // Darker Rice Paper
                        "paper-dark": "#1A1D21", 
                        "primary": "#00A3FF"
                    },
                    fontFamily: {
                        "display": ["Space Grotesk", "sans-serif"],
                        "mono": ["JetBrains Mono", "monospace"]
                    },
                },
            },
        }
    </script>
    <style type="text/tailwindcss">
        @layer base {
            body {
                @apply bg-background-light dark:bg-background-dark text-slate-900 dark:text-slate-300 font-display;
            }
        }
        /* Custom paper texture effect */
        .paper-texture {
            background-color: #E6E6E6; /* Darker fallback */
            background-image: linear-gradient(180deg, rgba(255,255,255,0.45) 0%, rgba(232,232,232,0.92) 100%);
            box-shadow: inset 0 0 40px rgba(0,0,0,0.1);
        }
        .dark .paper-texture {
            background-color: #1A1D21; 
            background-image: linear-gradient(180deg, rgba(28,32,40,0.98) 0%, rgba(20,24,32,0.98) 100%);
            opacity: 1;
        }
        .paper-preview-surface {
            @apply relative w-full h-full overflow-y-auto custom-scrollbar p-5;
        }
        .paper-guide {
            @apply absolute inset-5 rounded-md pointer-events-none;
            opacity: 0.9;
        }
        .paper-guide-letter21 {
            background-image: repeating-linear-gradient(
                to bottom,
                rgba(108, 108, 108, 0.35) 0,
                rgba(108, 108, 108, 0.35) 1px,
                transparent 1px,
                transparent 33px
            );
        }
        .dark .paper-guide-letter21 {
            background-image: repeating-linear-gradient(
                to bottom,
                rgba(148, 163, 184, 0.24) 0,
                rgba(148, 163, 184, 0.24) 1px,
                transparent 1px,
                transparent 33px
            );
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.02);
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #30363D;
            border-radius: 10px;
        }
        input[type="range"] {
            @apply appearance-none bg-lab-border h-1 rounded-full;
        }
        input[type="range"]::-webkit-slider-thumb {
            @apply appearance-none w-3 h-3 bg-lab-blue rounded-full cursor-pointer hover:ring-4 hover:ring-lab-blue/20 transition-all;
        }
        .writing-grid {
            @apply relative z-10 w-full min-h-[420px] grid content-start;
            grid-template-columns: repeat(5, minmax(0, 1fr));
            gap: 12px;
        }
        .paper-grid-400 .writing-grid {
            grid-template-columns: repeat(20, minmax(0, 1fr));
            gap: 0;
            border-left: 1px solid rgba(118, 118, 118, 0.42);
            border-top: 1px solid rgba(118, 118, 118, 0.42);
        }
        .dark .paper-grid-400 .writing-grid {
            border-left-color: rgba(148, 163, 184, 0.3);
            border-top-color: rgba(148, 163, 184, 0.3);
        }
        .paper-letter-21 .writing-grid {
            grid-template-columns: repeat(20, minmax(0, 1fr));
            gap: 0;
            grid-auto-rows: 34px;
        }
        .paper-letter-21 .writing-cell {
            aspect-ratio: auto;
            border: 0;
            border-radius: 0;
            background: transparent;
        }
        .dark .paper-letter-21 .writing-cell {
            background: transparent;
        }
        .paper-grid-400 .writing-cell {
            border: 0;
            border-right: 1px solid rgba(118, 118, 118, 0.42);
            border-bottom: 1px solid rgba(118, 118, 118, 0.42);
            border-radius: 0;
            background: transparent;
            opacity: 1;
        }
        .dark .paper-grid-400 .writing-cell {
            border-right-color: rgba(148, 163, 184, 0.3);
            border-bottom-color: rgba(148, 163, 184, 0.3);
        }
        .writing-cell {
            @apply relative aspect-square border rounded-xl overflow-hidden bg-white/40 dark:bg-black/10;
            border-color: rgba(148, 163, 184, 0.35);
        }
        .writing-cell.state-pending {
            @apply opacity-60;
        }
        .writing-cell.state-writing {
            border-color: rgba(0, 163, 255, 0.6);
            box-shadow: 0 0 0 2px rgba(0, 163, 255, 0.15);
        }
        .writing-cell.state-pass {
            border-color: rgba(166, 255, 0, 0.6);
        }
        .writing-cell.state-fail {
            border-color: rgba(248, 113, 113, 0.65);
            background-color: rgba(127, 29, 29, 0.08);
        }
        .paper-letter-21 .writing-cell.state-pass {
            box-shadow: inset 0 -2px 0 rgba(166, 255, 0, 0.72);
        }
        .paper-letter-21 .writing-cell.state-writing {
            box-shadow: inset 0 -2px 0 rgba(0, 163, 255, 0.45);
        }
        .paper-letter-21 .writing-cell.state-fail {
            box-shadow: inset 0 -2px 0 rgba(248, 113, 113, 0.72);
            background-color: rgba(127, 29, 29, 0.06);
        }
        .paper-grid-400 .writing-cell.state-writing {
            box-shadow: inset 0 0 0 2px rgba(0, 163, 255, 0.6);
        }
        .paper-grid-400 .writing-cell.state-pass {
            box-shadow: inset 0 0 0 2px rgba(166, 255, 0, 0.68);
        }
        .paper-grid-400 .writing-cell.state-fail {
            box-shadow: inset 0 0 0 2px rgba(248, 113, 113, 0.72);
        }
        .writing-reference {
            @apply absolute inset-0 flex items-center justify-center text-slate-400/55 dark:text-slate-500/45 select-none pointer-events-none;
            font-size: clamp(1.3rem, 1.8vw, 1.8rem);
            font-family: "Noto Serif SC", "Songti SC", serif;
        }
        .paper-letter-21 .writing-reference {
            font-size: clamp(1rem, 1.2vw, 1.2rem);
        }
        .writing-glyph {
            @apply absolute inset-0 flex items-center justify-center;
        }
        .writing-glyph img {
            @apply w-[88%] h-[88%] object-contain;
            filter: invert(1);
        }
        .paper-letter-21 .writing-glyph img {
            width: 76%;
            height: 76%;
        }
        .dark .writing-glyph img {
            filter: none;
        }
        .stroke-demo-card {
            @apply border border-lab-border rounded-lg bg-lab-bg/70 p-4 space-y-3;
        }
        .stroke-demo-overlay {
            @apply p-0 bg-transparent border-0 rounded-none backdrop-blur-0;
        }
        .stroke-demo-svg {
            @apply w-full h-24 bg-transparent border border-lab-border/60 rounded;
        }
        .stroke-path-base {
            fill: rgba(148, 163, 184, 0.28);
        }
        .stroke-path-complete {
            fill: rgba(0, 163, 255, 0.86);
        }
        .stroke-path-current {
            fill: rgba(0, 163, 255, 0.98);
        }
        .stroke-median-line {
            fill: none;
            stroke: rgba(166, 255, 0, 0.95);
            stroke-width: 32;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        .stroke-median-start {
            fill: rgba(250, 204, 21, 0.95);
        }
        .stroke-median-end {
            fill: rgba(248, 113, 113, 0.95);
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden bg-background-light dark:bg-background-dark text-slate-900 dark:text-slate-300">
    
    <!-- Top Navigation -->
    <header class="border-b border-lab-border bg-lab-bg/95 backdrop-blur-sm sticky top-0 z-50">
        <div class="max-w-[1400px] mx-auto px-8 h-16 flex items-center justify-between">
            <div class="flex items-center gap-4">
                <div class="w-10 h-10 flex items-center justify-center">
                    <img src="/static/mohen.svg" class="w-8 h-8" alt="MoHen Logo" />
                </div>
                <div class="flex flex-col leading-none">
                    <h1 class="text-[11px] font-black tracking-[0.25em] text-white uppercase">Handwriting Lab</h1>
                    <span class="text-[9px] font-bold text-lab-blue tracking-widest uppercase">Version 1.2</span>
                </div>
            </div>
            <div class="flex items-center h-full gap-8">
                <nav class="flex h-full">
                    <a class="px-6 flex items-center text-[11px] font-bold uppercase tracking-[0.2em] text-lab-muted hover:text-white transition-colors h-full" href="/">Clone</a>
                    <a class="px-6 flex items-center text-[11px] font-bold uppercase tracking-[0.2em] text-lab-blue border-b-2 border-lab-blue h-full" href="/generate">Generate</a>
                </nav>
                <div class="hidden flex items-center gap-5 border-l border-lab-border pl-8">
                    <div class="w-8 h-8 rounded border border-lab-border bg-lab-card flex items-center justify-center">
                        <span class="material-symbols-outlined text-sm text-lab-muted">person</span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex-1 flex overflow-hidden">
        
        <!-- Left Sidebar: Controls -->
        <section class="w-[380px] border-r border-lab-border flex flex-col bg-lab-card overflow-y-auto custom-scrollbar">
            <div class="p-6 space-y-8">
                
                <!-- Content Input -->
                <div class="space-y-3">
                    <div class="flex justify-between items-end">
                        <label class="text-[10px] font-mono uppercase tracking-widest text-lab-muted">Content Input</label>
                        <span class="text-[9px] font-mono text-slate-600">UTF-8 / MULTI-LANG</span>
                    </div>
                    <div class="relative group">
                        <textarea id="text-input" class="w-full h-48 bg-lab-bg border border-lab-border rounded-lg p-4 text-sm font-display leading-relaxed focus:ring-1 focus:ring-lab-blue/50 focus:border-lab-blue outline-none transition-all placeholder:text-slate-700 custom-scrollbar text-white" placeholder="Enter text to synthesize...">天道酬勤。志之所趋，无远弗届，穷山距海，不能限也。志之所向，无坚不入，锐兵精甲，不能御也。</textarea>
                        <div class="absolute bottom-3 right-3 text-[9px] font-mono text-slate-600">CHARS: <span id="char-count">42</span></div>
                    </div>
                </div>

                <!-- Font Style Selection (New) -->
                <div class="space-y-3">
                    <div class="flex justify-between items-end">
                        <label class="text-[10px] font-mono uppercase tracking-widest text-lab-muted">Font Style</label>
                        <button onclick="openStyleManager()" class="text-[9px] font-mono text-lab-blue hover:underline">MANAGE STYLES</button>
                    </div>
                    <div class="relative">
                        <select id="style-select" class="w-full bg-lab-bg border border-lab-border rounded-lg px-4 py-3 text-sm font-mono text-white appearance-none focus:ring-1 focus:ring-lab-blue/50 focus:border-lab-blue outline-none cursor-pointer">
                            <option value="">Loading styles...</option>
                        </select>
                        <div class="absolute right-3 top-3 pointer-events-none text-lab-muted">
                            <span class="material-symbols-outlined text-sm">expand_more</span>
                        </div>
                    </div>
                </div>

                <div class="space-y-3">
                    <div class="flex justify-between items-end">
                        <label class="text-[10px] font-mono uppercase tracking-widest text-lab-muted">Paper Settings</label>
                    </div>
                    <div class="relative">
                        <select id="paper-template" class="w-full bg-lab-bg border border-lab-border rounded-lg px-4 py-3 text-sm font-mono text-white appearance-none focus:ring-1 focus:ring-lab-blue/50 focus:border-lab-blue outline-none cursor-pointer">
                            <option value="grid400" selected>400 Grid Manuscript</option>
                            <option value="letter21">21-line Letter Paper</option>
                        </select>
                        <div class="absolute right-3 top-3 pointer-events-none text-lab-muted">
                            <span class="material-symbols-outlined text-sm">article</span>
                        </div>
                    </div>
                </div>

                <div class="stroke-demo-card">
                    <div class="flex items-center justify-between text-[10px] font-mono uppercase tracking-widest text-lab-muted">
                        <span>Stroke Demo (Make Me a Hanzi)</span>
                        <span id="stroke-source" class="text-lab-blue">idle</span>
                    </div>
                    <div class="flex gap-2">
                        <select id="stroke-char-select" class="flex-1 bg-lab-bg border border-lab-border rounded px-3 py-2 text-xs font-mono text-white focus:ring-1 focus:ring-lab-blue/50 focus:border-lab-blue outline-none">
                            <option value="">No character</option>
                        </select>
                        <button id="stroke-play-btn" class="px-3 py-2 bg-lab-blue/90 hover:bg-lab-blue text-white rounded text-[11px] font-bold">PLAY</button>
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                        <label class="text-[10px] text-lab-muted flex items-center justify-between gap-2">
                            <span>Threshold</span>
                            <input id="stroke-threshold" type="number" min="0.50" max="0.98" step="0.01" value="0.72" class="w-20 bg-lab-bg border border-lab-border rounded px-2 py-1 text-xs text-white" />
                        </label>
                        <label class="text-[10px] text-lab-muted flex items-center justify-between gap-2">
                            <span>Max Retries</span>
                            <input id="stroke-max-retries" type="number" min="0" max="6" step="1" value="2" class="w-20 bg-lab-bg border border-lab-border rounded px-2 py-1 text-xs text-white" />
                        </label>
                    </div>
                    <button id="stroke-flow-btn" class="w-full px-3 py-2 bg-lab-green/90 hover:bg-lab-green text-black rounded text-[11px] font-bold">RUN STROKE FLOW (DEMO)</button>
                    <div id="stroke-status" class="text-[10px] text-lab-muted">Select a character to preview stroke order.</div>
                </div>

                <!-- Run Button (Moved up) -->
                <button id="run-btn" class="w-full bg-lab-green hover:bg-[#d9ff33] text-black font-bold py-4 rounded-lg flex items-center justify-center gap-3 transition-all active:scale-[0.98] shadow-lg shadow-lab-green/5">
                    <span class="material-symbols-outlined">analytics</span>
                    RUN SYNTHESIS ENGINE
                </button>

                <div class="border border-lab-border rounded-lg bg-lab-bg/70 p-4 space-y-3">
                    <div class="flex items-center justify-between text-[10px] font-mono uppercase tracking-widest text-lab-muted">
                        <span>Quality Metrics</span>
                        <span id="quality-method" class="text-lab-blue">Waiting</span>
                    </div>
                    <div class="grid grid-cols-3 gap-3 text-center">
                        <div>
                            <div class="text-[9px] text-lab-muted uppercase tracking-wider">CER est.</div>
                            <div id="metric-cer" class="text-sm font-bold text-white">--</div>
                        </div>
                        <div>
                            <div class="text-[9px] text-lab-muted uppercase tracking-wider">Accuracy</div>
                            <div id="metric-acc" class="text-sm font-bold text-white">--</div>
                        </div>
                        <div>
                            <div class="text-[9px] text-lab-muted uppercase tracking-wider">Errors</div>
                            <div id="metric-err" class="text-sm font-bold text-white">--</div>
                        </div>
                    </div>
                    <div class="text-[10px] text-lab-muted" id="metric-meta">Run synthesis to compute estimated typo rate.</div>
                    <div class="text-[10px] text-red-300/80 max-h-20 overflow-y-auto custom-scrollbar" id="metric-mismatch"></div>
                </div>
            </div>
        </section>

        <!-- Right Preview: Canvas -->
        <section class="flex-1 relative bg-lab-bg overflow-hidden flex flex-col">
            <!-- Canvas Container -->
            <div id="paper-viewport" class="absolute inset-0 flex items-center justify-center p-12 pb-32 overflow-hidden select-none">
                <!-- Paper Sheet -->
                <div id="paper-sheet" class="w-full max-w-4xl aspect-[1.4/1] paper-texture rounded shadow-2xl shadow-black/50 relative overflow-hidden flex flex-col p-6 group transition-all paper-grid-400">
                    <div class="flex items-center justify-between px-3 pb-3 border-b border-black/10 dark:border-white/10">
                        <div class="text-zinc-700 dark:text-zinc-300 text-[11px] font-mono uppercase tracking-wider">Writing Sheet Preview</div>
                        <div class="text-zinc-500 dark:text-zinc-400 text-[10px] font-mono uppercase tracking-wider">Template follows left panel</div>
                    </div>
                    <div class="paper-preview-surface text-zinc-900 dark:text-zinc-300">
                        <div id="paper-guide" class="paper-guide paper-guide-grid400"></div>
                        <div id="writing-grid" class="writing-grid">
                            <!-- Writing cells will appear here -->
                        </div>
                    </div>
                    
                    <!-- Paper Metadata -->
                    <div id="paper-meta" class="absolute bottom-4 right-4 text-[9px] font-mono text-zinc-400 opacity-60">
                        TEMPLATE: 400_GRID // AUTO_SCORE: STROKE_LEVEL
                    </div>
                </div>

            </div>

            <!-- Canvas Controls -->
            <div class="absolute top-6 right-6 flex flex-col gap-2">
                <button onclick="zoom(0.1)" class="p-2 bg-lab-card border border-lab-border rounded text-slate-400 hover:text-lab-blue transition-colors">
                    <span class="material-symbols-outlined">zoom_in</span>
                </button>
                <button onclick="zoom(-0.1)" class="p-2 bg-lab-card border border-lab-border rounded text-slate-400 hover:text-lab-blue transition-colors">
                    <span class="material-symbols-outlined">zoom_out</span>
                </button>
                <button id="hand-pan-btn" onclick="toggleHandMode()" class="p-2 bg-lab-card border border-lab-border rounded text-slate-400 hover:text-lab-blue transition-colors" title="Hand tool (Space to hold)">
                    <span class="material-symbols-outlined">pan_tool</span>
                </button>
                <button onclick="resetZoom()" class="p-2 bg-lab-card border border-lab-border rounded text-slate-400 hover:text-lab-blue transition-colors">
                    <span class="material-symbols-outlined">fit_screen</span>
                </button>
            </div>

            <!-- Export Bar -->
            <div class="mt-auto p-6 bg-lab-card/80 backdrop-blur-sm border-t border-lab-border grid grid-cols-1 gap-4">
                <div class="border border-lab-border rounded-xl bg-lab-bg/60 p-3 flex items-center gap-4">
                    <div id="stroke-overlay" class="stroke-demo-overlay w-24 shrink-0">
                        <div class="flex items-center justify-between mb-1 text-[9px] font-mono uppercase tracking-widest text-lab-muted">
                            <span>Preview</span>
                            <span id="stroke-overlay-char" class="text-lab-blue">--</span>
                        </div>
                        <svg id="stroke-demo-svg" class="stroke-demo-svg" viewBox="0 0 1024 1024" preserveAspectRatio="xMidYMid meet"></svg>
                    </div>

                    <div class="w-px self-stretch bg-lab-border/80"></div>

                    <div class="flex-1 grid grid-cols-5 gap-2 text-center">
                        <div>
                            <div class="text-[9px] uppercase tracking-wider text-lab-muted">Progress</div>
                            <div id="status-progress" class="text-sm font-bold text-white">0/0</div>
                        </div>
                        <div>
                            <div class="text-[9px] uppercase tracking-wider text-lab-muted">Stroke</div>
                            <div id="status-stroke" class="text-sm font-bold text-white">--</div>
                        </div>
                        <div>
                            <div class="text-[9px] uppercase tracking-wider text-lab-muted">Score</div>
                            <div id="status-score" class="text-sm font-bold text-white">--</div>
                        </div>
                        <div>
                            <div class="text-[9px] uppercase tracking-wider text-lab-muted">Retries</div>
                            <div id="status-retries" class="text-sm font-bold text-white">0</div>
                        </div>
                        <div>
                            <div class="text-[9px] uppercase tracking-wider text-lab-muted">Failed Chars</div>
                            <div id="status-failed" class="text-sm font-bold text-red-300">0</div>
                        </div>
                    </div>
                </div>

                <div id="stroke-step-info" class="text-[10px] text-slate-400 px-1">Waiting for stroke data...</div>

                <div class="border border-lab-border rounded-xl bg-lab-bg/60 p-4">
                    <div class="flex items-center justify-between mb-3">
                        <div class="text-[10px] font-mono uppercase tracking-widest text-lab-muted">Failed Characters (Skipped for analysis)</div>
                        <label class="text-[10px] text-lab-muted flex items-center gap-2">
                            <input id="follow-current" type="checkbox" class="rounded border-lab-border bg-lab-bg text-lab-blue focus:ring-lab-blue/50" checked>
                            Follow current char
                        </label>
                    </div>
                    <div id="failed-list" class="max-h-24 overflow-y-auto custom-scrollbar text-[11px] text-slate-300">No failed characters.</div>
                    <div class="mt-3 pt-3 border-t border-lab-border/70">
                        <div class="flex items-center justify-between text-[10px] font-mono uppercase tracking-widest text-lab-muted">
                            <span>Deferred (Discuss Later)</span>
                            <span id="deferred-count" class="text-lab-blue">0</span>
                        </div>
                        <div id="deferred-list" class="mt-2 max-h-16 overflow-y-auto custom-scrollbar text-[11px] text-slate-400">No deferred items.</div>
                    </div>
                </div>

                <button onclick="exportPNG()" class="flex items-center justify-center gap-3 py-4 border border-lab-border rounded-xl text-slate-300 hover:bg-lab-bg hover:border-lab-blue/50 transition-all group">
                    <span class="material-symbols-outlined text-slate-500 group-hover:text-lab-blue">image</span>
                    <div class="text-left">
                        <div class="text-xs font-bold uppercase">Export as High-Res PNG</div>
                        <div class="text-[9px] text-slate-500 font-mono">LOSSLESS COMPRESSION</div>
                    </div>
                </button>
                <!-- SVG Export Temporarily Disabled
                <button onclick="exportSVG()" ...>
                -->
            </div>
        </section>
    </div>

    <!-- Footer -->
    <footer class="h-10 px-6 border-t border-lab-border flex justify-between items-center text-[10px] font-mono text-slate-600 bg-lab-bg">
        <div class="flex gap-6">
            <span class="flex items-center gap-2">
                <span class="w-1.5 h-1.5 bg-lab-blue/40 rounded-full"></span> 
                GPU_ACCELERATION: ENABLED
            </span>
            <span>LATENCY: 142MS</span>
            <span>MEM: 1.4GB / 8GB</span>
        </div>
        <div class="flex gap-4">
            <span class="text-slate-700">|</span>
            <span>PROTO_SYNTH_VER: 0.8.2-ALPHA</span>
            <span>© 2024 LABS</span>
        </div>
    </footer>

    <!-- Style Manager Modal -->
    <div id="style-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm opacity-0 pointer-events-none transition-opacity duration-300">
        <div class="bg-lab-card border border-lab-border w-[500px] max-h-[80vh] flex flex-col rounded-xl shadow-2xl transform scale-95 transition-transform duration-300" id="style-modal-content">
            <div class="p-6 border-b border-lab-border flex justify-between items-center">
                <h3 class="text-white font-bold text-lg">Manage Font Styles</h3>
                <button onclick="closeStyleManager()" class="text-lab-muted hover:text-white transition-colors">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
            <div class="p-6 overflow-y-auto custom-scrollbar flex-1 space-y-4" id="style-list">
                <!-- Styles will be injected here -->
                <div class="text-center text-lab-muted py-8">Loading...</div>
            </div>
            <div class="p-6 border-t border-lab-border bg-lab-bg/50">
                <button onclick="closeStyleManager()" class="w-full py-3 bg-lab-border/50 text-white rounded hover:bg-lab-border transition-colors text-xs font-bold uppercase tracking-wider">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Character Counter
        const textInput = document.getElementById('text-input');
        const charCount = document.getElementById('char-count');
        const writingGrid = document.getElementById('writing-grid');
        const runBtn = document.getElementById('run-btn');
        const paperViewport = document.getElementById('paper-viewport');
        const paperSheet = document.getElementById('paper-sheet');
        const handPanBtn = document.getElementById('hand-pan-btn');
        const paperTemplate = document.getElementById('paper-template');
        const paperGuide = document.getElementById('paper-guide');
        const paperMeta = document.getElementById('paper-meta');
        const statusProgress = document.getElementById('status-progress');
        const statusStroke = document.getElementById('status-stroke');
        const statusScore = document.getElementById('status-score');
        const statusRetries = document.getElementById('status-retries');
        const statusFailed = document.getElementById('status-failed');
        const failedList = document.getElementById('failed-list');
        const deferredCount = document.getElementById('deferred-count');
        const deferredList = document.getElementById('deferred-list');
        const followCurrent = document.getElementById('follow-current');
        const DEFAULT_VARIATION = 0.64;
        const DEFAULT_DENSITY = 82;
        const metricCer = document.getElementById('metric-cer');
        const metricAcc = document.getElementById('metric-acc');
        const metricErr = document.getElementById('metric-err');
        const metricMeta = document.getElementById('metric-meta');
        const metricMismatch = document.getElementById('metric-mismatch');
        const metricMethod = document.getElementById('quality-method');
        const strokeCharSelect = document.getElementById('stroke-char-select');
        const strokePlayBtn = document.getElementById('stroke-play-btn');
        const strokeFlowBtn = document.getElementById('stroke-flow-btn');
        const strokeThresholdInput = document.getElementById('stroke-threshold');
        const strokeMaxRetriesInput = document.getElementById('stroke-max-retries');
        const strokeStatus = document.getElementById('stroke-status');
        const strokeSource = document.getElementById('stroke-source');
        const strokeDemoSvg = document.getElementById('stroke-demo-svg');
        const strokeOverlayChar = document.getElementById('stroke-overlay-char');
        const strokeStepInfo = document.getElementById('stroke-step-info');

        const writingState = {
            visibleChars: [],
            cursor: 0,
            failedItems: [],
            deferredItems: []
        };

        const strokeDemoState = {
            dataByChar: new Map(),
            playing: false,
            playTimer: null,
            flowRunning: false
        };
        const STROKE_PREVIEW_UP_OFFSET = 88;

        let isGenerating = false;

        const qualitySummary = {
            evaluated: 0,
            errors: 0,
            confidenceWeightedSum: 0,
            mismatches: [],
            guidance: 0,
            steps: 0,
            variation: 0,
            method: 'waiting'
        };

        textInput.addEventListener('input', () => {
            charCount.textContent = textInput.value.length;
            refreshStrokeCharOptions();
            if (!isGenerating) {
                renderPreviewScaffold();
            }
        });

        function resetQualityPanel(statusText = 'Waiting') {
            qualitySummary.evaluated = 0;
            qualitySummary.errors = 0;
            qualitySummary.confidenceWeightedSum = 0;
            qualitySummary.mismatches = [];
            qualitySummary.guidance = 0;
            qualitySummary.steps = 0;
            qualitySummary.variation = 0;
            qualitySummary.method = statusText;

            metricMethod.textContent = statusText;
            metricCer.textContent = '--';
            metricAcc.textContent = '--';
            metricErr.textContent = '--';
            metricMeta.textContent = 'Run synthesis to compute estimated typo rate.';
            metricMismatch.textContent = '';
        }

        function mergeQualityMetrics(quality, offset = 0) {
            if (!quality) {
                return;
            }

            const evaluated = Number(quality.evaluated || 0);
            const errors = Number(quality.errors || 0);
            const meanConfidence = Number(quality.mean_confidence || 0);

            qualitySummary.evaluated += evaluated;
            qualitySummary.errors += errors;
            qualitySummary.confidenceWeightedSum += (meanConfidence * evaluated);
            qualitySummary.method = quality.method || qualitySummary.method;
            qualitySummary.guidance = Number(quality.guidance_scale || qualitySummary.guidance || 0);
            qualitySummary.steps = Number(quality.steps || qualitySummary.steps || 0);
            qualitySummary.variation = Number(quality.variation || qualitySummary.variation || 0);

            if (Array.isArray(quality.mismatches)) {
                quality.mismatches.forEach(item => {
                    if (qualitySummary.mismatches.length >= 10) {
                        return;
                    }
                    qualitySummary.mismatches.push({
                        pos: Number(item.pos || 0) + offset,
                        expected: item.expected || '?',
                        predicted: item.predicted || '?',
                        confidence: Number(item.confidence || 0)
                    });
                });
            }

            const cer = qualitySummary.evaluated > 0 ? qualitySummary.errors / qualitySummary.evaluated : 0;
            const acc = 1 - cer;
            const conf = qualitySummary.evaluated > 0 ? qualitySummary.confidenceWeightedSum / qualitySummary.evaluated : 0;

            metricMethod.textContent = qualitySummary.method === 'template_match_proxy' ? 'Template OCR' : qualitySummary.method;
            metricCer.textContent = `${(cer * 100).toFixed(1)}%`;
            metricAcc.textContent = `${(acc * 100).toFixed(1)}%`;
            metricErr.textContent = `${qualitySummary.errors}/${qualitySummary.evaluated}`;
            metricMeta.textContent = `Guidance: ${qualitySummary.guidance.toFixed(2)} | Steps: ${qualitySummary.steps} | Mean conf: ${conf.toFixed(2)}`;

            if (qualitySummary.mismatches.length === 0) {
                metricMismatch.textContent = 'No mismatches detected in current estimate.';
            } else {
                metricMismatch.textContent = qualitySummary.mismatches
                    .map(item => `#${item.pos + 1}: ${item.expected} -> ${item.predicted} (${item.confidence.toFixed(2)})`)
                    .join(' | ');
            }
        }

        resetQualityPanel();

        function getVisibleChars(text) {
            return Array.from(text).filter(ch => ch.trim().length > 0);
        }

        function applyPaperTemplate(template) {
            paperSheet.classList.remove('paper-grid-400', 'paper-letter-21');
            if (template === 'letter21') {
                paperSheet.classList.add('paper-letter-21');
                paperGuide.classList.remove('hidden');
                paperGuide.classList.add('paper-guide-letter21');
                paperMeta.textContent = 'TEMPLATE: 21_LINE_LETTER // AUTO_SCORE: STROKE_LEVEL';
            } else {
                paperSheet.classList.add('paper-grid-400');
                paperGuide.classList.add('hidden');
                paperGuide.classList.remove('paper-guide-letter21');
                paperMeta.textContent = 'TEMPLATE: 400_GRID // AUTO_SCORE: STROKE_LEVEL';
            }
        }

        function getTemplateSlotCount(template) {
            return template === 'grid400' ? 400 : 420;
        }

        function buildWritingSurface(visibleChars) {
            const slotCount = Math.max(getTemplateSlotCount(paperTemplate.value), visibleChars.length);
            writingState.visibleChars = visibleChars;
            writingGrid.innerHTML = '';
            for (let idx = 0; idx < slotCount; idx++) {
                const char = visibleChars[idx] || '';
                const cell = document.createElement('div');
                cell.className = 'writing-cell state-pending';
                cell.dataset.index = String(idx);
                cell.innerHTML = `<div class="writing-reference">${char}</div><div class="writing-glyph"></div>`;
                writingGrid.appendChild(cell);
            }
        }

        function resetWritingSurface(visibleChars) {
            writingState.cursor = 0;
            writingState.failedItems = [];
            writingState.deferredItems = [];
            buildWritingSurface(visibleChars);
            statusProgress.textContent = `0/${visibleChars.length}`;
            statusStroke.textContent = '--';
            statusScore.textContent = '--';
            statusRetries.textContent = '0';
            statusFailed.textContent = '0';
            failedList.textContent = 'No failed characters.';
            deferredCount.textContent = '0';
            deferredList.textContent = 'No deferred items.';
        }

        function renderPreviewScaffold() {
            const visibleChars = getVisibleChars(textInput.value);
            buildWritingSurface(visibleChars);
            statusProgress.textContent = `0/${visibleChars.length}`;
        }

        function refreshStrokeCharOptions() {
            const chars = [];
            const seen = new Set();
            for (const ch of getVisibleChars(textInput.value)) {
                if (seen.has(ch)) continue;
                seen.add(ch);
                chars.push(ch);
                if (chars.length >= 40) break;
            }

            const current = strokeCharSelect.value;
            strokeCharSelect.innerHTML = '';
            if (chars.length === 0) {
                strokeCharSelect.innerHTML = '<option value="">No character</option>';
                strokeOverlayChar.textContent = '--';
                strokeStepInfo.textContent = 'Waiting for stroke data...';
                strokeDemoSvg.innerHTML = '';
                return;
            }

            chars.forEach(ch => {
                const opt = document.createElement('option');
                opt.value = ch;
                opt.textContent = ch;
                strokeCharSelect.appendChild(opt);
            });

            if (current && chars.includes(current)) {
                strokeCharSelect.value = current;
            }
        }

        async function fetchStrokeDataForChar(char) {
            if (!char) return null;
            if (strokeDemoState.dataByChar.has(char)) {
                return strokeDemoState.dataByChar.get(char);
            }

            const res = await fetch(`/api/stroke_order?char=${encodeURIComponent(char)}`);
            const data = await res.json();
            const item = Array.isArray(data.items) && data.items.length > 0 ? data.items[0] : null;
            if (item) {
                strokeDemoState.dataByChar.set(char, item);
            }
            return item;
        }

        function renderStrokeFrame(item, activeIndex = -1) {
            strokeDemoSvg.innerHTML = '';
            strokeOverlayChar.textContent = item?.char || '--';

            if (!item || !item.available || !Array.isArray(item.strokes) || item.strokes.length === 0) {
                strokeStepInfo.textContent = 'No stroke data for this character.';
                strokeSource.textContent = item?.source || 'n/a';
                return;
            }

            strokeSource.textContent = item.source || 'remote';
            strokeStepInfo.textContent = activeIndex >= 0
                ? `Stroke ${Math.min(activeIndex + 1, item.strokes.length)}/${item.strokes.length}`
                : `Total strokes: ${item.strokes.length}`;

            const strokeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            strokeGroup.setAttribute('transform', `translate(0, ${1024 - STROKE_PREVIEW_UP_OFFSET}) scale(1, -1)`);
            strokeDemoSvg.appendChild(strokeGroup);

            item.strokes.forEach((pathData, idx) => {
                const base = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                base.setAttribute('d', pathData);
                base.setAttribute('class', 'stroke-path-base');
                strokeGroup.appendChild(base);

                if (idx < activeIndex) {
                    const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    highlight.setAttribute('d', pathData);
                    highlight.setAttribute('class', 'stroke-path-complete');
                    strokeGroup.appendChild(highlight);
                } else if (idx === activeIndex) {
                    const current = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    current.setAttribute('d', pathData);
                    current.setAttribute('class', 'stroke-path-current');
                    strokeGroup.appendChild(current);

                    const medianPoints = Array.isArray(item.medians?.[idx]) ? item.medians[idx] : [];
                    if (medianPoints.length >= 2) {
                        const pointText = medianPoints.map(point => `${point[0]},${point[1]}`).join(' ');
                        const medianPolyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                        medianPolyline.setAttribute('points', pointText);
                        medianPolyline.setAttribute('class', 'stroke-median-line');
                        strokeGroup.appendChild(medianPolyline);

                        const startPoint = medianPoints[0];
                        const endPoint = medianPoints[medianPoints.length - 1];

                        const startDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        startDot.setAttribute('cx', String(startPoint[0]));
                        startDot.setAttribute('cy', String(startPoint[1]));
                        startDot.setAttribute('r', '26');
                        startDot.setAttribute('class', 'stroke-median-start');
                        strokeGroup.appendChild(startDot);

                        const endDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        endDot.setAttribute('cx', String(endPoint[0]));
                        endDot.setAttribute('cy', String(endPoint[1]));
                        endDot.setAttribute('r', '22');
                        endDot.setAttribute('class', 'stroke-median-end');
                        strokeGroup.appendChild(endDot);

                        const dx = endPoint[0] - startPoint[0];
                        const dyScreen = startPoint[1] - endPoint[1];
                        const horizontal = dx > 24 ? 'left→right' : (dx < -24 ? 'right→left' : 'horizontal-stable');
                        const vertical = dyScreen > 24 ? 'top→bottom' : (dyScreen < -24 ? 'bottom→top' : 'vertical-stable');
                        strokeStepInfo.textContent = `Stroke ${Math.min(activeIndex + 1, item.strokes.length)}/${item.strokes.length} · ${horizontal} · ${vertical}`;
                    }
                }
            });
        }

        function stopStrokePlayback() {
            strokeDemoState.playing = false;
            if (strokeDemoState.playTimer) {
                clearTimeout(strokeDemoState.playTimer);
                strokeDemoState.playTimer = null;
            }
            strokePlayBtn.textContent = 'PLAY';
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function pointDistance(a, b) {
            return Math.hypot((a[0] || 0) - (b[0] || 0), (a[1] || 0) - (b[1] || 0));
        }

        function polylineLength(points) {
            if (!Array.isArray(points) || points.length < 2) return 0;
            let total = 0;
            for (let i = 1; i < points.length; i++) {
                total += pointDistance(points[i - 1], points[i]);
            }
            return total;
        }

        function resamplePolyline(points, targetCount = 12) {
            if (!Array.isArray(points) || points.length === 0) return [];
            if (points.length === 1) return Array.from({ length: targetCount }, () => [...points[0]]);

            const segmentLengths = [];
            let totalLength = 0;
            for (let i = 1; i < points.length; i++) {
                const segLen = pointDistance(points[i - 1], points[i]);
                segmentLengths.push(segLen);
                totalLength += segLen;
            }
            if (totalLength <= 1e-6) {
                return Array.from({ length: targetCount }, () => [...points[0]]);
            }

            const sampled = [];
            for (let k = 0; k < targetCount; k++) {
                const targetDist = (k / Math.max(targetCount - 1, 1)) * totalLength;
                let walked = 0;
                let placed = false;

                for (let i = 1; i < points.length; i++) {
                    const segLen = segmentLengths[i - 1];
                    if (walked + segLen >= targetDist) {
                        const t = segLen > 1e-6 ? (targetDist - walked) / segLen : 0;
                        const x = points[i - 1][0] + (points[i][0] - points[i - 1][0]) * t;
                        const y = points[i - 1][1] + (points[i][1] - points[i - 1][1]) * t;
                        sampled.push([x, y]);
                        placed = true;
                        break;
                    }
                    walked += segLen;
                }

                if (!placed) {
                    sampled.push([...points[points.length - 1]]);
                }
            }
            return sampled;
        }

        function buildStyleProfile(char) {
            const code = char.codePointAt(0) || 0;
            const hashA = (Math.sin(code * 0.017) + 1) / 2;
            const hashB = (Math.sin(code * 0.031 + 1.7) + 1) / 2;
            const hashC = (Math.sin(code * 0.043 + 2.9) + 1) / 2;
            return {
                scaleX: 0.86 + hashA * 0.32,
                scaleY: 0.86 + hashB * 0.32,
                slant: (hashC - 0.5) * 0.14,
                baseNoise: 10 + hashB * 18
            };
        }

        function synthesizeCandidateMedian(referenceMedian, styleProfile, strokeIndex, retryIndex) {
            if (!Array.isArray(referenceMedian) || referenceMedian.length < 2) return [];

            const pts = resamplePolyline(referenceMedian, 12);
            const cx = pts.reduce((sum, p) => sum + p[0], 0) / pts.length;
            const cy = pts.reduce((sum, p) => sum + p[1], 0) / pts.length;
            const retryDecay = Math.max(0.32, 1 - retryIndex * 0.28);

            return pts.map((p, idx) => {
                const x0 = p[0] - cx;
                const y0 = p[1] - cy;
                const slantedX = x0 + y0 * styleProfile.slant;
                const sx = slantedX * styleProfile.scaleX;
                const sy = y0 * styleProfile.scaleY;

                const localSeed = (strokeIndex + 1) * 37 + (idx + 1) * 13;
                const jitterX = Math.sin(localSeed * 0.37) * styleProfile.baseNoise * retryDecay;
                const jitterY = Math.cos(localSeed * 0.41) * styleProfile.baseNoise * retryDecay;

                return [cx + sx + jitterX, cy + sy + jitterY];
            });
        }

        function computeDirectionScore(refPts, candPts) {
            if (refPts.length < 2 || candPts.length < 2) return 0.5;
            const ra = refPts[0], rb = refPts[refPts.length - 1];
            const ca = candPts[0], cb = candPts[candPts.length - 1];
            const rvx = rb[0] - ra[0], rvy = rb[1] - ra[1];
            const cvx = cb[0] - ca[0], cvy = cb[1] - ca[1];
            const rnorm = Math.hypot(rvx, rvy), cnorm = Math.hypot(cvx, cvy);
            if (rnorm < 1e-6 || cnorm < 1e-6) return 0.5;
            const cos = (rvx * cvx + rvy * cvy) / (rnorm * cnorm);
            return Math.max(0, Math.min(1, (cos + 1) / 2));
        }

        function computeLengthScore(refPts, candPts) {
            const rl = polylineLength(refPts);
            const cl = polylineLength(candPts);
            if (rl < 1e-6 || cl < 1e-6) return 0.5;
            const ratio = cl / rl;
            return Math.max(0, 1 - Math.min(1, Math.abs(1 - ratio) / 0.55));
        }

        function computePositionScore(refPts, candPts) {
            if (refPts.length === 0 || candPts.length === 0) return 0.5;
            const rcx = refPts.reduce((sum, p) => sum + p[0], 0) / refPts.length;
            const rcy = refPts.reduce((sum, p) => sum + p[1], 0) / refPts.length;
            const ccx = candPts.reduce((sum, p) => sum + p[0], 0) / candPts.length;
            const ccy = candPts.reduce((sum, p) => sum + p[1], 0) / candPts.length;
            const d = Math.hypot(ccx - rcx, ccy - rcy);
            return Math.max(0, 1 - Math.min(1, d / 180));
        }

        function computeShapeScore(refPts, candPts) {
            if (refPts.length === 0 || candPts.length === 0) return 0.5;
            const count = Math.min(refPts.length, candPts.length);
            let sum = 0;
            for (let i = 0; i < count; i++) {
                sum += pointDistance(refPts[i], candPts[i]);
            }
            const mean = sum / Math.max(count, 1);
            return Math.max(0, 1 - Math.min(1, mean / 170));
        }

        function evaluateStrokeQuality(referenceMedian, candidateMedian) {
            const refPts = resamplePolyline(referenceMedian, 12);
            const candPts = resamplePolyline(candidateMedian, 12);

            const pos = computePositionScore(refPts, candPts);
            const dir = computeDirectionScore(refPts, candPts);
            const len = computeLengthScore(refPts, candPts);
            const shape = computeShapeScore(refPts, candPts);

            const correctness = 0.55 * dir + 0.30 * len + 0.15 * shape;
            const style = 0.50 * shape + 0.30 * pos + 0.20 * dir;
            const final = 0.75 * correctness + 0.25 * style;

            return {
                correctness: Math.max(0, Math.min(1, correctness)),
                style: Math.max(0, Math.min(1, style)),
                final: Math.max(0, Math.min(1, final)),
                components: { pos, dir, len, shape }
            };
        }

        function setDemoButtonsBusy(busy) {
            if (busy) {
                strokeFlowBtn.classList.add('opacity-70', 'pointer-events-none');
                strokePlayBtn.classList.add('opacity-70', 'pointer-events-none');
                runBtn.classList.add('opacity-70', 'pointer-events-none');
            } else {
                strokeFlowBtn.classList.remove('opacity-70', 'pointer-events-none');
                strokePlayBtn.classList.remove('opacity-70', 'pointer-events-none');
                runBtn.classList.remove('opacity-70', 'pointer-events-none');
            }
        }

        function isPunctuationChar(ch) {
            if (!ch || !ch.trim()) return false;
            return /[\p{P}\p{S}]/u.test(ch);
        }

        function pushFailedChar(char, index, reason) {
            writingState.failedItems.push({ char, index, reason });
            failedList.innerHTML = writingState.failedItems
                .slice(-20)
                .map(item => `#${item.index} ${item.char} · ${item.reason}`)
                .join('<br>');
            statusFailed.textContent = String(writingState.failedItems.length);
        }

        function pushDeferredChar(char, index, reason) {
            writingState.deferredItems.push({ char, index, reason });
            deferredCount.textContent = String(writingState.deferredItems.length);
            deferredList.innerHTML = writingState.deferredItems
                .slice(-20)
                .map(item => `#${item.index} ${item.char} · ${item.reason}`)
                .join('<br>');
        }

        async function runStrokeFlowDemo() {
            if (strokeDemoState.flowRunning) {
                strokeStatus.textContent = 'Stroke flow is already running.';
                return;
            }

            const visibleChars = getVisibleChars(textInput.value);
            if (visibleChars.length === 0) {
                strokeStatus.textContent = 'Please input text first.';
                return;
            }

            const threshold = Math.max(0.5, Math.min(0.98, Number(strokeThresholdInput.value || 0.72)));
            const maxRetries = Math.max(0, Math.min(6, parseInt(strokeMaxRetriesInput.value || '2', 10)));
            const correctnessGate = Math.max(0.66, threshold - 0.08);

            strokeDemoState.flowRunning = true;
            stopStrokePlayback();
            setDemoButtonsBusy(true);
            strokeFlowBtn.textContent = 'RUNNING...';

            resetWritingSurface(visibleChars);
            strokeStatus.textContent = `Flow started · threshold ${threshold.toFixed(2)} · gate(C) ${correctnessGate.toFixed(2)} · retries ${maxRetries}`;

            let progressIndex = 0;

            try {
                for (let charIndex = 0; charIndex < visibleChars.length; charIndex++) {
                    const char = visibleChars[charIndex];
                    const styleProfile = buildStyleProfile(char);
                    const cell = writingGrid.querySelector(`[data-index="${charIndex}"]`);
                    if (cell) {
                        cell.classList.remove('state-pending', 'state-pass', 'state-fail');
                        cell.classList.add('state-writing');
                        if (followCurrent.checked) {
                            cell.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                        }
                    }

                    if (isPunctuationChar(char)) {
                        progressIndex += 1;
                        writingState.cursor = progressIndex;
                        if (cell) {
                            cell.classList.remove('state-writing');
                            cell.classList.add('state-pass');
                        }
                        pushDeferredChar(char, charIndex + 1, 'Punctuation deferred');
                        strokeStatus.textContent = `${char} deferred (punctuation)`;
                        updateWritingStatus({
                            cursor: progressIndex,
                            score: null,
                            retries: 0,
                            strokeLabel: 'defer'
                        });
                        await sleep(80);
                        continue;
                    }

                    const item = await fetchStrokeDataForChar(char);
                    if (!item || !item.available || !Array.isArray(item.strokes) || item.strokes.length === 0) {
                        if (cell) {
                            cell.classList.remove('state-writing');
                            cell.classList.add('state-fail');
                        }
                        pushFailedChar(char, charIndex + 1, 'No stroke data');
                        updateWritingStatus({ cursor: progressIndex, score: 0, retries: 0, strokeLabel: 'no-data' });
                        continue;
                    }

                    let charPassed = true;
                    for (let strokeIndex = 0; strokeIndex < item.strokes.length; strokeIndex++) {
                        const referenceMedian = Array.isArray(item.medians?.[strokeIndex]) ? item.medians[strokeIndex] : [];
                        if (referenceMedian.length < 2) {
                            charPassed = false;
                            if (cell) {
                                cell.classList.remove('state-writing');
                                cell.classList.add('state-fail');
                            }
                            pushFailedChar(char, charIndex + 1, `Stroke ${strokeIndex + 1} missing median`);
                            strokeStatus.textContent = `${char} skipped (stroke data incomplete)`;
                            break;
                        }

                        let passed = false;
                        for (let retry = 0; retry <= maxRetries; retry++) {
                            const candidateMedian = synthesizeCandidateMedian(referenceMedian, styleProfile, strokeIndex, retry);
                            const quality = evaluateStrokeQuality(referenceMedian, candidateMedian);
                            const gatePassed = quality.correctness >= correctnessGate;
                            const finalPassed = quality.final >= threshold;

                            renderStrokeFrame(item, strokeIndex);
                            strokeStatus.textContent = `${char} · stroke ${strokeIndex + 1}/${item.strokes.length} · try ${retry + 1} · C ${quality.correctness.toFixed(2)} / S ${quality.style.toFixed(2)} / F ${quality.final.toFixed(2)}`;
                            updateWritingStatus({
                                cursor: progressIndex,
                                score: quality.final,
                                retries: retry,
                                strokeLabel: `${strokeIndex + 1}/${item.strokes.length}`
                            });

                            await sleep(240);
                            if (gatePassed && finalPassed) {
                                passed = true;
                                break;
                            }
                        }

                        if (!passed) {
                            charPassed = false;
                            if (cell) {
                                cell.classList.remove('state-writing');
                                cell.classList.add('state-fail');
                            }
                            pushFailedChar(char, charIndex + 1, `Stroke ${strokeIndex + 1} below threshold`);
                            strokeStatus.textContent = `${char} skipped (stroke ${strokeIndex + 1} failed)`;
                            break;
                        }
                    }

                    if (charPassed) {
                        progressIndex += 1;
                        writingState.cursor = progressIndex;
                        if (cell) {
                            cell.classList.remove('state-writing');
                            cell.classList.add('state-pass');
                        }
                    }

                    updateWritingStatus({
                        cursor: progressIndex,
                        score: null,
                        retries: 0,
                        strokeLabel: charPassed ? 'pass' : 'skip'
                    });

                    await sleep(120);
                }

                strokeStatus.textContent = `Flow complete · pass ${progressIndex}/${visibleChars.length} · failed ${writingState.failedItems.length}`;
                strokeFlowBtn.textContent = 'FLOW COMPLETE';
            } catch (err) {
                console.error(err);
                strokeStatus.textContent = `Flow failed: ${err?.message || 'unknown error'}`;
                strokeFlowBtn.textContent = 'FLOW FAILED';
            } finally {
                strokeDemoState.flowRunning = false;
                setDemoButtonsBusy(false);
                setTimeout(() => {
                    strokeFlowBtn.textContent = 'RUN STROKE FLOW (DEMO)';
                }, 900);
            }
        }

        async function previewSelectedStrokeChar(play = false) {
            const char = strokeCharSelect.value;
            if (!char) {
                strokeStatus.textContent = 'No character selected.';
                return;
            }

            strokeStatus.textContent = `Loading stroke data for ${char}...`;
            const item = await fetchStrokeDataForChar(char);
            if (!item || !item.available) {
                stopStrokePlayback();
                renderStrokeFrame(item, -1);
                strokeStatus.textContent = `No Make Me a Hanzi data for ${char}.`;
                return;
            }

            if (!play) {
                stopStrokePlayback();
                renderStrokeFrame(item, -1);
                strokeStatus.textContent = `${char}: ${item.stroke_count} strokes ready.`;
                return;
            }

            if (strokeDemoState.playing) {
                stopStrokePlayback();
                renderStrokeFrame(item, -1);
                strokeStatus.textContent = 'Playback stopped.';
                return;
            }

            strokeDemoState.playing = true;
            strokePlayBtn.textContent = 'STOP';
            strokeStatus.textContent = `Playing ${char} stroke order...`;

            let step = 0;
            const playStep = () => {
                if (!strokeDemoState.playing) return;
                renderStrokeFrame(item, step);
                step += 1;
                if (step < item.strokes.length) {
                    strokeDemoState.playTimer = setTimeout(playStep, 420);
                } else {
                    stopStrokePlayback();
                    strokeStatus.textContent = `${char} stroke playback finished.`;
                }
            };

            renderStrokeFrame(item, -1);
            strokeDemoState.playTimer = setTimeout(playStep, 180);
        }

        function updateWritingStatus({ cursor = 0, score = null, retries = 0, strokeLabel = '--' } = {}) {
            const total = writingState.visibleChars.length;
            statusProgress.textContent = `${Math.min(cursor, total)}/${total}`;
            statusStroke.textContent = strokeLabel;
            statusScore.textContent = score === null ? '--' : Number(score).toFixed(2);
            statusRetries.textContent = String(retries || 0);
            statusFailed.textContent = String(writingState.failedItems.length);
        }

        function appendGeneratedGlyphCells(urls, chars, startIndex, data) {
            const score = data?.stroke_eval?.score ?? data?.quality?.mean_confidence ?? null;
            const strokeLabel = data?.stroke_eval?.stroke_label || '--';
            const retries = data?.stroke_eval?.retries || 0;
            const failed = [];

            urls.forEach((url, localIdx) => {
                const globalIdx = startIndex + localIdx;
                const cell = writingGrid.querySelector(`[data-index="${globalIdx}"]`);
                if (!cell) return;

                cell.classList.remove('state-pending', 'state-writing', 'state-pass', 'state-fail');
                cell.classList.add('state-writing');

                const glyphWrap = cell.querySelector('.writing-glyph');
                glyphWrap.innerHTML = '';
                const img = document.createElement('img');
                img.src = url;
                img.className = 'glyph-img';
                glyphWrap.appendChild(img);

                const mismatchHit = Array.isArray(data?.quality?.mismatches) && data.quality.mismatches.some(item => Number(item.pos) === localIdx);
                if (mismatchHit) {
                    cell.classList.remove('state-writing');
                    cell.classList.add('state-fail');
                    failed.push({ char: chars[localIdx] || '?', index: globalIdx + 1, reason: 'Position trend mismatch' });
                } else {
                    cell.classList.remove('state-writing');
                    cell.classList.add('state-pass');
                }

                if (followCurrent.checked) {
                    cell.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                }

                writingState.cursor = globalIdx + 1;
            });

            if (failed.length > 0) {
                writingState.failedItems.push(...failed);
                failedList.innerHTML = writingState.failedItems
                    .slice(-20)
                    .map(item => `#${item.index} ${item.char} · ${item.reason}`)
                    .join('<br>');
            }

            updateWritingStatus({
                cursor: writingState.cursor,
                score,
                retries,
                strokeLabel
            });
        }

        function splitTextIntoChunks(text, chunkSize) {
            const chars = Array.from(text);
            const chunks = [];
            for (let i = 0; i < chars.length; i += chunkSize) {
                chunks.push(chars.slice(i, i + chunkSize).join(''));
            }
            return chunks;
        }

        function setButtonsBusy(isBusy) {
            isGenerating = isBusy;
            if (isBusy) {
                runBtn.classList.add('opacity-75', 'pointer-events-none');
            } else {
                runBtn.classList.remove('opacity-75', 'pointer-events-none');
            }
        }

        async function generateChunks({ chunks, style, variation, density, onProgress, onChunkDone }) {
            let visibleOffset = 0;
            for (let i = 0; i < chunks.length; i++) {
                if (onProgress) {
                    onProgress(i, chunks.length);
                }

                const chunkText = chunks[i];
                const chunkOffset = visibleOffset;
                const chunkVisibleChars = getVisibleChars(chunkText);
                visibleOffset += chunkVisibleChars.length;

                const res = await fetch('/api/generate', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        text: chunkText,
                        style_dir: style,
                        variation: parseFloat(variation),
                        density: parseInt(density),
                        chunk_index: i
                    })
                });

                const data = await res.json();
                if (!res.ok || !data.images) {
                    throw new Error(data.message || 'Unknown error');
                }

                if (onChunkDone) {
                    onChunkDone(data, { chunkIndex: i, chunkOffset, chunkText, chunkVisibleChars });
                }
            }
        }

        // Run Synthesis (Progressive)
        runBtn.addEventListener('click', async () => {
            const text = textInput.value;
            const style = styleSelect.value;
            const variation = DEFAULT_VARIATION;
            const density = DEFAULT_DENSITY;
            
            if (!style) {
                alert('Please select a font style first.');
                return;
            }
            if (!text.trim()) {
                alert('Please enter some text.');
                return;
            }
            
            const originalText = runBtn.innerHTML;
            runBtn.innerHTML = `<span class="material-symbols-outlined animate-spin">refresh</span> SYNTHESIZING 0%...`;
            setButtonsBusy(true);

            resetQualityPanel('Running');
            const visibleChars = getVisibleChars(text);
            resetWritingSurface(visibleChars);

            const chunkSize = 6;
            const chunks = splitTextIntoChunks(text, chunkSize).filter(chunk => chunk.trim().length > 0);

            if (chunks.length === 0) {
                alert('Please enter visible characters.');
                runBtn.innerHTML = originalText;
                setButtonsBusy(false);
                return;
            }
            
            try {
                await generateChunks({
                    chunks,
                    style,
                    variation,
                    density,
                    onProgress: (index, total) => {
                        const progress = Math.round((index / total) * 100);
                        runBtn.innerHTML = `<span class="material-symbols-outlined animate-spin">refresh</span> SYNTHESIZING ${progress}% (${index + 1}/${total})`;
                    },
                    onChunkDone: (data, context) => {
                        appendGeneratedGlyphCells(data.images, context.chunkVisibleChars, context.chunkOffset, data);
                        mergeQualityMetrics(data.quality, context.chunkOffset);
                    }
                });

                runBtn.innerHTML = `<span class="material-symbols-outlined">check_circle</span> SYNTHESIS COMPLETE`;
            } catch (err) {
                console.error(err);
                alert('Generation failed: ' + (err.message || 'Network error during synthesis'));
            } finally {
                runBtn.innerHTML = originalText;
                setButtonsBusy(false);
            }
        });

        paperTemplate.addEventListener('change', (e) => {
            applyPaperTemplate(e.target.value);
            if (!isGenerating) {
                renderPreviewScaffold();
            }
        });

        applyPaperTemplate(paperTemplate.value);
        renderPreviewScaffold();
        refreshStrokeCharOptions();
        if (strokeCharSelect.value) {
            previewSelectedStrokeChar(false).catch(err => {
                console.error(err);
                strokeStatus.textContent = 'Failed to load stroke preview.';
            });
        }

        strokeCharSelect.addEventListener('change', () => {
            previewSelectedStrokeChar(false).catch(err => {
                console.error(err);
                strokeStatus.textContent = 'Failed to load stroke preview.';
            });
        });

        strokePlayBtn.addEventListener('click', () => {
            previewSelectedStrokeChar(true).catch(err => {
                console.error(err);
                stopStrokePlayback();
                strokeStatus.textContent = 'Stroke playback failed.';
            });
        });

        strokeFlowBtn.addEventListener('click', () => {
            runStrokeFlowDemo().catch(err => {
                console.error(err);
                strokeDemoState.flowRunning = false;
                setDemoButtonsBusy(false);
                strokeStatus.textContent = 'Flow runner crashed unexpectedly.';
                strokeFlowBtn.textContent = 'RUN STROKE FLOW (DEMO)';
            });
        });

        // Zoom Logic
        let currentZoom = 1;
        let panOffsetX = 0;
        let panOffsetY = 0;
        let handModeEnabled = false;
        let spacePanEnabled = false;
        let draggingPaper = false;
        let activePointerId = null;
        const panStart = { x: 0, y: 0, ox: 0, oy: 0 };

        function isEditableTarget(target) {
            if (!target) return false;
            const tag = (target.tagName || '').toLowerCase();
            return tag === 'input' || tag === 'textarea' || target.isContentEditable;
        }

        function isPanAvailable() {
            return handModeEnabled || spacePanEnabled || currentZoom > 1.01;
        }

        function updatePanCursor() {
            if (draggingPaper) {
                paperViewport.style.cursor = 'grabbing';
            } else if (isPanAvailable()) {
                paperViewport.style.cursor = 'grab';
            } else {
                paperViewport.style.cursor = 'default';
            }

            if (handModeEnabled) {
                handPanBtn.classList.add('text-lab-blue', 'border-lab-blue/60', 'bg-lab-blue/10');
            } else {
                handPanBtn.classList.remove('text-lab-blue', 'border-lab-blue/60', 'bg-lab-blue/10');
            }
        }

        function clampPanOffsets(x, y) {
            const viewportRect = paperViewport.getBoundingClientRect();
            const baseWidth = paperSheet.offsetWidth;
            const baseHeight = paperSheet.offsetHeight;
            const scaledWidth = baseWidth * currentZoom;
            const scaledHeight = baseHeight * currentZoom;

            const maxX = Math.max(0, (scaledWidth - viewportRect.width) / 2);
            const maxY = Math.max(0, (scaledHeight - viewportRect.height) / 2);

            return {
                x: Math.max(-maxX, Math.min(maxX, x)),
                y: Math.max(-maxY, Math.min(maxY, y))
            };
        }

        function applyPaperTransform() {
            const clamped = clampPanOffsets(panOffsetX, panOffsetY);
            panOffsetX = clamped.x;
            panOffsetY = clamped.y;
            paperSheet.style.transformOrigin = 'center center';
            paperSheet.style.transform = `translate(${panOffsetX}px, ${panOffsetY}px) scale(${currentZoom})`;
            updatePanCursor();
        }

        function startPaperDrag(clientX, clientY, pointerId = null) {
            if (!isPanAvailable()) return;
            draggingPaper = true;
            activePointerId = pointerId;
            panStart.x = clientX;
            panStart.y = clientY;
            panStart.ox = panOffsetX;
            panStart.oy = panOffsetY;
            updatePanCursor();
        }

        function movePaperDrag(clientX, clientY) {
            if (!draggingPaper) return;
            panOffsetX = panStart.ox + (clientX - panStart.x);
            panOffsetY = panStart.oy + (clientY - panStart.y);
            applyPaperTransform();
        }

        function endPaperDrag() {
            draggingPaper = false;
            activePointerId = null;
            updatePanCursor();
        }

        function toggleHandMode() {
            handModeEnabled = !handModeEnabled;
            updatePanCursor();
        }
        
        
        function zoom(delta) {
            currentZoom += delta;
            currentZoom = Math.max(0.5, Math.min(2, currentZoom));
            if (currentZoom <= 1.01) {
                panOffsetX = 0;
                panOffsetY = 0;
            }
            applyPaperTransform();
        }
        
        function resetZoom() {
            currentZoom = 1;
            panOffsetX = 0;
            panOffsetY = 0;
            applyPaperTransform();
        }

        paperViewport.addEventListener('mousedown', (event) => {
            if (event.button !== 0) return;
            if (!event.target.closest('#paper-sheet')) return;
            if (!isPanAvailable()) return;
            event.preventDefault();
            startPaperDrag(event.clientX, event.clientY);
        });

        window.addEventListener('mousemove', (event) => {
            movePaperDrag(event.clientX, event.clientY);
        });

        window.addEventListener('mouseup', () => {
            endPaperDrag();
        });

        paperViewport.addEventListener('pointerdown', (event) => {
            if (event.pointerType === 'mouse') return;
            if (!event.target.closest('#paper-sheet')) return;
            if (!isPanAvailable()) return;
            event.preventDefault();
            paperViewport.setPointerCapture(event.pointerId);
            startPaperDrag(event.clientX, event.clientY, event.pointerId);
        });

        paperViewport.addEventListener('pointermove', (event) => {
            if (activePointerId !== event.pointerId) return;
            movePaperDrag(event.clientX, event.clientY);
        });

        paperViewport.addEventListener('pointerup', (event) => {
            if (activePointerId === event.pointerId) {
                endPaperDrag();
            }
        });

        window.addEventListener('keydown', (event) => {
            if (event.code !== 'Space') return;
            if (isEditableTarget(event.target)) return;
            if (!spacePanEnabled) {
                event.preventDefault();
                spacePanEnabled = true;
                updatePanCursor();
            }
        });

        window.addEventListener('keyup', (event) => {
            if (event.code !== 'Space') return;
            spacePanEnabled = false;
            updatePanCursor();
        });

        window.addEventListener('blur', () => {
            spacePanEnabled = false;
            endPaperDrag();
        });

        window.addEventListener('resize', () => {
            applyPaperTransform();
        });

        applyPaperTransform();

        // Style Management
        const styleSelect = document.getElementById('style-select');
        const styleModal = document.getElementById('style-modal');
        const styleModalContent = document.getElementById('style-modal-content');
        const styleList = document.getElementById('style-list');
        let availableStyles = [];

        function loadStyles() {
            fetch('/api/styles')
                .then(res => res.json())
                .then(data => {
                    availableStyles = data;
                    renderStyleSelect();
                    renderStyleList();
                })
                .catch(err => {
                    console.error("Failed to load styles:", err);
                    styleSelect.innerHTML = '<option>Error loading styles</option>';
                });
        }

        function renderStyleSelect() {
            styleSelect.innerHTML = '';
            
            // Check if no styles available
            if (availableStyles.length === 0) {
                styleSelect.innerHTML = '<option value="">No styles found</option>';
                // Zero State: Disable Generate
                runBtn.disabled = true;
                runBtn.classList.add('opacity-50', 'cursor-not-allowed', 'grayscale');
                runBtn.innerHTML = `
                    <span class="material-symbols-outlined">info</span>
                    NO STYLES AVAILABLE
                `;
                runBtn.title = "Please clone a handwriting style first.";
                return;
            }
            
            // Restore button state if styles exist
            runBtn.disabled = false;
            runBtn.classList.remove('opacity-50', 'cursor-not-allowed', 'grayscale');
            runBtn.innerHTML = `
                <span class="material-symbols-outlined">analytics</span>
                RUN SYNTHESIS ENGINE
            `;
            runBtn.title = "";

            availableStyles.forEach(style => {
                const opt = document.createElement('option');
                opt.value = style.dir_name;
                opt.textContent = style.font_name;
                styleSelect.appendChild(opt);
            });
        }

        function openStyleManager() {
            styleModal.classList.remove('pointer-events-none', 'opacity-0');
            styleModalContent.classList.remove('scale-95');
            renderStyleList();
        }

        function closeStyleManager() {
            styleModal.classList.add('pointer-events-none', 'opacity-0');
            styleModalContent.classList.add('scale-95');
        }

        function renderStyleList() {
            styleList.innerHTML = '';
            if (availableStyles.length === 0) {
                styleList.innerHTML = '<div class="text-center text-lab-muted py-8">No styles saved yet.</div>';
                return;
            }

            availableStyles.forEach(style => {
                const div = document.createElement('div');
                div.className = "bg-lab-bg border border-lab-border rounded-lg p-4 flex items-center justify-between group hover:border-lab-blue/50 transition-colors";
                
                const date = new Date(style.created_at * 1000).toLocaleDateString();
                
                div.innerHTML = `
                    <div>
                        <div class="font-bold text-white text-sm">${style.font_name}</div>
                        <div class="text-[10px] text-lab-muted font-mono mt-1">CREATED: ${date}</div>
                    </div>
                    <div class="flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                        <button onclick="deleteStyle('${style.dir_name}')" class="p-2 hover:bg-red-500/20 hover:text-red-500 rounded text-lab-muted transition-colors" title="Delete">
                            <span class="material-symbols-outlined text-sm">delete</span>
                        </button>
                    </div>
                `;
                styleList.appendChild(div);
            });
        }

        function deleteStyle(dirName) {
            if (!confirm('Are you sure you want to delete this font style? This action cannot be undone.')) return;
            
            fetch('/api/delete_style', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ name: dirName })
            })
            .then(res => {
                if (res.ok) {
                    loadStyles(); // Reload
                } else {
                    alert('Failed to delete style');
                }
            });
        }

        // Initial Load
        loadStyles();

        // Export Functions
        async function exportPNG() {
            const container = document.getElementById('writing-grid');
            const images = container.querySelectorAll('img.glyph-img');
            if (images.length === 0) return alert("No content to export");

            // Compute robust bounds from actual rendered image rects to avoid clipping.
            const containerRect = container.getBoundingClientRect();
            const rendered = [];
            let minX = Number.POSITIVE_INFINITY;
            let minY = Number.POSITIVE_INFINITY;
            let maxX = Number.NEGATIVE_INFINITY;
            let maxY = Number.NEGATIVE_INFINITY;

            for (let img of images) {
                if (!img.complete) continue;
                const rect = img.getBoundingClientRect();
                const x = (rect.left - containerRect.left) + container.scrollLeft;
                const y = (rect.top - containerRect.top) + container.scrollTop;
                const w = rect.width;
                const h = rect.height;
                rendered.push({ img, x, y, w, h });
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x + w);
                maxY = Math.max(maxY, y + h);
            }

            if (rendered.length === 0) return alert("Images are not ready yet. Please wait and retry.");

            const padding = 12;
            const width = Math.max(1, Math.ceil((maxX - minX) + padding * 2));
            const height = Math.max(1, Math.ceil((maxY - minY) + padding * 2));
            
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // Invert filter for black ink
            ctx.filter = 'invert(1)';
            
            for (let item of rendered) {
                const drawX = (item.x - minX) + padding;
                const drawY = (item.y - minY) + padding;
                ctx.drawImage(item.img, drawX, drawY, item.w, item.h);
            }
            ctx.filter = 'none';
            
            const link = document.createElement('a');
            link.download = `mohen_export_${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        async function exportSVG() {
            // Check if library is loaded
            if (typeof ImageTracer === 'undefined') {
                alert("Vector engine (ImageTracer) not loaded. Please check your internet connection.");
                return;
            }

            const container = document.getElementById('writing-grid');
            const images = container.querySelectorAll('img.glyph-img');
            if (images.length === 0) return alert("No content to export");
            
            const width = container.scrollWidth;
            const height = container.scrollHeight;
            
            let svgBody = '';
            
            // Trace Helper
            const traceImage = (img) => {
                return new Promise(resolve => {
                    const c = document.createElement('canvas');
                    c.width = img.naturalWidth;
                    c.height = img.naturalHeight;
                    const cx = c.getContext('2d');
                    
                    // Draw inverted (White -> Black) for better tracing of "ink"
                    cx.filter = 'invert(1)';
                    cx.drawImage(img, 0, 0);
                    cx.filter = 'none';
                    
                    const imageData = cx.getImageData(0,0, c.width, c.height);
                    
                    // Tracer options for clean single-color output
                    const options = { 
                        ltres: 1, 
                        qtres: 1, 
                        pathomit: 8, 
                        colorsampling: 0, // Deterministic
                        numberofcolors: 2, 
                        mincolorratio: 0, 
                        colorquantcycles: 0, 
                        strokewidth: 0, 
                        linefilter: true,
                        scale: 1,
                        viewbox: false // We handle viewbox
                    };
                    
                    // We need to capture the output string. 
                    // ImageTracer.imagedataToSVG returns string.
                    try {
                        const svgStr = ImageTracer.imagedataToSVG(imageData, options);
                        resolve(svgStr);
                    } catch (e) {
                        console.error(e);
                        resolve('');
                    }
                });
            };

            for (let img of images) {
                if (!img.complete) continue;
                
                const x = img.offsetLeft;
                const y = img.offsetTop;
                const w = img.offsetWidth;
                const h = img.offsetHeight;
                
                // Scale from natural size to display size
                const scaleX = w / img.naturalWidth;
                const scaleY = h / img.naturalHeight;
                
                const rawSvg = await traceImage(img);
                if (!rawSvg) continue;
                
                // Extract path data. ImageTracer produces <svg ...><path ...></svg>
                // We want to extract <path d="..." ... /> and strip fill/stroke to override them
                // Or just take the content.
                // Simple parser: find first <path and last />
                
                // Better: Parse XML
                const parser = new DOMParser();
                const doc = parser.parseFromString(rawSvg, "image/svg+xml");
                const paths = doc.querySelectorAll('path');
                
                let groupContent = '';
                paths.forEach(p => {
                    // Force fill black
                    p.setAttribute('fill', '#000000');
                    p.removeAttribute('stroke');
                    groupContent += p.outerHTML;
                });
                
                svgBody += `<g transform="translate(${x},${y}) scale(${scaleX}, ${scaleY})">${groupContent}</g>`;
            }
            
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">${svgBody}</svg>`;
            
            const blob = new Blob([svg], {type: "image/svg+xml"});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = `mohen_vector_${Date.now()}.svg`;
            link.href = url;
            link.click();
        }
    </script>
</body>
</html>